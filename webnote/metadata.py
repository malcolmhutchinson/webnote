"""Classes implimenting the simple filesystem syntax.
"""

import copy
import os
import settings

class Metadata():
    """Provide services for dealing with metadata.

    This class knows all about the metadata files. Give it the
    pathname to a file and it will determine where the metafile is,
    read it and return a list of key/value pairs.

    It can also create a metafile for a new page, and guess the
    contents of certain fields, like title, author, etc.

    A metafile record looks like this:

        # Dublin Core metadata record
        DC.Title:       Webnote
        DC.Creator:     Malcolm Hutchinson
        DC.Subject:     Filesystem syntax, information systems, Django, Python
        DC.Description: Filesystem services implimenting the simple syntax.
        DC.Contributor:
        DC.Coverage:    New Zealand
        DC.Date:        2015-04-03
        DC.Type:
        DC.Format:      text/html
        DC.Source:
        DC.Language:    en
        DC.Identifier:
        DC.Publisher:   Malcolm Hutchinson
        DC.Relation:
        DC.Rights:      cc-by
        # END DC metadata

        # Page command options
        sort-reverse:   false # true
        deny:           all
        allow:          staff
        status:         draft
        # END page command

    This class takes a page address, which is the address generated by
    a Webnote object, pointing to a page (text or HTML file).

    This class can read a file containing a record like this, and
    parse it into a metadata structure.

    The metafile is represented by a list stored at
    self.filemodel, containing (key, value) tuples. These are
    obtained by splitting each line at the colon, and returning the
    first element as key, and a re-stitched list of the rest as value.

    """

    DC_METADATA = (
        "dc_title",
        "dc_creator",
        "dc_subject",
        "dc_description",
        "dc_contributor",
        "dc_coverage",
        "dc_date",
        "dc_type",
        "dc_format",
        "dc_source",
        "dc_language",
        "dc_relation",
        "dc_identifier",
        "dc_rights",
        "dc_publisher",
    )

    COMMANDS = (
        'status',
        'sort',
        'deny',
        'allow',
        'embargo',
    )

    warnings = []

    data = None
    filemodel = None
    metadata = None
    metafilename = None
    pagefile = None

    def __init__(self, pagefile=None, data=None):
        """Operations on metadata records.

        Instantiation creates a dictionary structure called
        `metadata`, holding lists of Dublin core elements, and
        commands.

        Initialise with an optional pathname to a page (without
        extension). Will search for a metafile under simple syntax
        rules, and read this file into the metadata structure.

        Initialise with data = a dictionary with those Dublin core and
        command keys, and it will load those values into the metadata
        structure.

        """

        metadata = {}
        for key in self.DC_METADATA:
            metadata[key] = [] 
        for key in self.COMMANDS:
            metadata[key] = []

        if pagefile:
            self.pagefile = pagefile
            self.metafilename = self.locate_metafile()

        if self.metafilename:
            self.filemodel = self.read_metafile()
        else:
            self.metadata = metadata

        if self.filemodel:
            self.metadata = self.process_filemodel(self.filemodel)

        if data:
            self.data = data
            self.metadata = self.process_data(data)
        
    def construct_metafile_record(self, data=None):
        """Return a string containing a metadata record in text format.

        A metafile is a string representation of a metarecord.

        This produces a string containing a record suitable for filing
        with pages in the document archive. It is intended to be
        written to a text file with a .meta suffix.

        If the metadata structure is empty, as at init, the result
        will be a file record with a list of keys, but no values.

        Normally used to create a metafile record for a new page, or
        one which doesn't have a metafile associated with it.

        """

        metafile = ''
        record = '# Dublin core metadata.\n'

        metadata = self.metadata

        
        for element in self.DC_METADATA:
            if element in metadata.keys():
                key = element.replace('dc_', 'DC.')
                record +=  key + ": "
                record += '; '.join(metadata[element]) + '\n'

        record += "# end Dublin core elements.\n\n"

        for element in self.COMMANDS:
            if element in metadata.keys():
                record += element + ": "
                #print metadata[element]
                record += '; '.join(metadata[element]) + '\n'
            
        
        #for line in metarecord:

        #    (key, value) = line
        #    if key.lower() == 'comment':
        #        key = '#'
        #    else:
        #        key = key + ":"
                
        #    if key.lower() == 'dc.title:':
        #        if not value:
        #            value = self.find_title()

            
        #    metafile += key
        #    metafile += '   '
        #    metafile += value + '\n'

        return record

    def save(self, data):
        """Save a metarecord to file."""

        print "SAVING metarecord"
        print self.construct_metafile_record()

#       Process the input dictionary into a metarecord
        
    def construct_metarecord(self):
        """Return a metarecord object from filespace data.

        A metarecord is a list of (key, value) tuples.
        """
        
        metarecord = [
            ('comment', 'Dublin core metadata record'),
        ]

        for line in sorted(self.DC_METADATA.keys()):
            metarecord.append((line, ''))

        metarecord.append(
            (('comment', 'End Dublin core metadata record')),
        )
        
        return metarecord

    def create_metafile(self, metarecord=None):
        """Create a file in the preferred metafile location.

        This method has SIDE EFFECTS!

        Write a metafile record into that file. 
        """

        (dirpath, filename) = os.path.split(self.preferred_filename())
        
        #dirpath = os.path.join(dirpath, 'meta')
        metafile = self.construct_metafile_record(metarecord=metarecord)

        filename = self.preferred_filename()
        if not os.path.isdir(dirpath):
            print "MAKING DIRECTORY AT ", dirpath
            os.mkdir(dirpath)

        if os.path.isfile(filename):
            print "METAFILE EXISTS AT ", filename
        else:
            print "WRITING METAFILE RECORD TO", filename
            f = open(filename, 'w')
            f.write(metafile)
            f.close()
            
        return (filename, metafile)
        
        
    def dublincore(self):

        """Return a list of DC metadata attribute names and values.

        List of (key, value) tuples taken from the metafile, with
        order and duplicated elements preserved.

        """

        dc = []

        for item in self.metadata.keys():
            if item[0][:3].upper() == 'DC.':
                dc.append(item)
        return dc

    def find_title(self):
        """Find the title from page content etc."""

        (path, fname) = os.path.split(self.pagefile)
        (basename, ext) = os.path.splitext(fname)
        title = basename.replace('_', ' ')

        return title
    

    def locate_metafile(self):
        """Locate the metafile for the given address.

        This follows this process:

        -   metafile in the parent directory.
        -   metafile in the meta directory.
        -   metafile in the paired directory.

        Return None if no file found.
        """

        (basename, ext) = os.path.splitext(self.pagefile)

        filename = basename + '.meta'

        if os.path.isfile(filename):
            return filename

        steps = basename.split('/')
        last = steps.pop()
        path = '/'.join(steps)
        metaname = last + '.meta'

        filename = os.path.join(path, 'meta', last + '.meta')

        if os.path.isfile(filename):
            return filename

        filename = os.path.join(basename, metaname)
        if os.path.isfile(filename):
            return filename

        return None

    def preferred_filename(self):
        """Return the preferred filename for a new metadata file.

        """

        filename = ''

        (path, pagefile) = os.path.split(self.pagefile)
        (basename, ext) = os.path.splitext(pagefile)

        filename = os.path.join(path, settings.META[0], basename + '.meta')

        return filename

    def process_filemodel(self, filemodel):
        """Convert self.metarecord into metadata and command structures.

        """

        metadata = {}

        # Ensures we can always reach for a dc_ element, and a command.
        for element in self.DC_METADATA:
            metadata[element.lower()] = []
        for element in self.COMMANDS:
            metadata[element.lower()] = []

        # Build the commands in as keys also
        for line in self.filemodel:
            
            if line[0].lower().replace('.', '_') in metadata.keys():
                metadata[line[0].lower().replace('.', '_')].append(line[1])

            elif line[0].lower() in self.COMMANDS:
                metadata[line[0]] = line[1]

        return metadata

    def read_metafile(self):
        """Return a metafile model structure from the metafile filename.

        Open and read the file, parse the contents into a filemodel structure.
        """

        record = [('filename', self.metafilename)]

        with open(self.metafilename) as f:
            contents = f.readlines()

        for line in contents:
            if line[0] == '#':
                key = 'comment'
                value = line[1:]
                record.append((key, value))
            else:
                bits = line.split(":")
                key = bits.pop(0)
                key = key.strip()
                value = ':'.join(bits)
                value = value.strip()
                record.append((key, value))

        return record

#   Methods to return individual field values.    
    def title(self):
        return '\n'. join(self.metadata['dc_title'])

    def author(self):
        return '; '.join(self.metadata['dc_creator'])

    def contributors(self):
        return '; '.join(self.metadata['dc_contributor'])

    def description(self):
        return '\n'.join(self.metadata['dc_description'])

    def doctype(self):
        return '; '.join(self.metadata['dc_type'])

    def fileformat(self):
        return '; '.join(self.metadata['dc_format'])

    def language(self):
        return ', '.join(self.metadata['dc_language'])

    def location(self):
        return ', '.join(self.metadata['dc_coverage'])

    def pubdate(self):
        if len(self.metadata['dc_date']) > 0:
            return self.metadata['dc_date'][0]
        else:
            return ""

    def publisher(self):
        return '; '.join(self.metadata['dc_publisher'])

    def rights(self):
        return '; '.join(self.metadata['dc_rights'])
    
    def rights_markup(self):
        """Return marked-up code for rights. """
        rights = None
        right = '; '.join(self.metadata['dc_rights'])
        if right in settings.LICENSES.keys():
            rights = "<a href='" + settings.LICENSES[right][0] + "'>"
            rights += settings.LICENSES[right][1] + "</a>"

        return rights
        
    def source(self):
        return '; '.join(self.metadata['dc_source'])

    def subject(self):
        return ', '.join(self.metadata['dc_subject'])

    def update_metadata(self, data):
        """Replace values in the metadata structure with supplied dictionary.

        This is often used with POST data.
        """

        return True

